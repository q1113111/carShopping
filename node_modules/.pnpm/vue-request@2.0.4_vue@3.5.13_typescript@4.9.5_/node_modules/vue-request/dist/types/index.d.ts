import { WritableComputedRef, ComputedRef, Ref, WatchSource } from 'vue-demi';

interface PaginationType {
    currentKey: string;
    pageSizeKey: string;
    totalKey: string;
    totalPageKey: string;
}
interface PaginationExtendsOption {
    pagination?: Partial<PaginationType>;
}
interface PaginationOptions<R, P extends unknown[]> extends Options<R, P>, PaginationExtendsOption {
}
interface PaginationQueryResult<R, P extends unknown[]> extends QueryResult<R, P> {
    current: WritableComputedRef<number>;
    pageSize: WritableComputedRef<number>;
    total: ComputedRef<number>;
    totalPage: ComputedRef<number>;
    changeCurrent: (current: number) => void;
    changePageSize: (pageSize: number) => void;
    changePagination: (current: number, pageSize: number) => void;
}
declare function usePagination<R, P extends unknown[] = any>(service: Service<R, P>, options?: PaginationOptions<R, P>): PaginationQueryResult<R, P>;

type CacheData<R = any, P = any> = {
    data: R;
    params: P;
    time: number;
};
type CacheKey = string;
declare const clearCache: (cacheKey?: CacheKey) => void;

type MutateData<R> = (newData: R) => void;
type MutateFunction<R> = (arg: (oldData: R) => R) => void;
type Service<R, P extends unknown[]> = (...args: P) => Promise<R>;
interface Mutate<R> extends MutateData<R>, MutateFunction<R> {
}
type State<R, P> = {
    loading: Ref<boolean>;
    data: Ref<R | undefined>;
    error: Ref<Error | undefined>;
    params: Ref<P>;
};
interface Query<R, P extends unknown[]> extends State<R, P> {
    status: Ref<'pending' | 'settled'>;
    context: FunctionContext<R, P>;
    plugins: Ref<Partial<PluginType<R, P>>[]>;
}
interface FunctionContext<R, P extends unknown[]> {
    runAsync: (...arg: P) => Promise<R>;
    run: (...arg: P) => void;
    cancel: () => void;
    refresh: () => void;
    refreshAsync: () => Promise<R>;
    mutate: Mutate<R>;
}
interface QueryResult<R, P extends unknown[]> extends State<R, P>, FunctionContext<R, P> {
}
interface DebounceOptions {
    leading?: boolean;
    trailing?: boolean;
    maxWait?: number;
}
type ThrottleOptions = Omit<DebounceOptions, 'maxWait'>;
type GlobalOptions = BaseOptions & PaginationExtendsOption;
type BaseOptions = {
    loadingDelay?: number | Ref<number>;
    loadingKeep?: number | Ref<number>;
    pollingInterval?: number | Ref<number>;
    pollingWhenHidden?: boolean;
    pollingWhenOffline?: boolean;
    debounceInterval?: number | Ref<number>;
    debounceOptions?: DebounceOptions;
    throttleOptions?: ThrottleOptions;
    throttleInterval?: number | Ref<number>;
    refreshOnWindowFocus?: boolean | Ref<boolean>;
    refocusTimespan?: number | Ref<number>;
    cacheTime?: number;
    staleTime?: number;
    manual?: boolean;
    errorRetryCount?: number | Ref<number>;
    errorRetryInterval?: number | Ref<number>;
    getCache?: (cacheKey: string) => CacheData;
    setCache?: (cacheKey: string, cacheData: CacheData) => void;
};
type Options<R, P extends unknown[]> = BaseOptions & {
    defaultParams?: P;
    ready?: Ref<boolean> | (() => boolean);
    initialData?: R;
    refreshDeps?: WatchSource | WatchSource[];
    cacheKey?: string | ((params?: P) => string);
    refreshDepsAction?: () => void;
    onSuccess?: (data: R, params: P) => void;
    onError?: (error: Error, params: P) => void;
    onBefore?: (params: P) => void;
    onAfter?: (params: P) => void;
};
type PluginImplementType<R, P extends any[]> = {
    (queryInstance: Query<R, P>, config: Options<R, P>): Partial<PluginType<R, P>>;
};
type PluginType<R, P extends unknown[]> = {
    onBefore: (params: P) => {
        isBreak?: Boolean;
        breakResult?: any;
    } | void;
    onQuery: (service: () => Promise<R>) => () => Promise<R>;
    onSuccess(data: R, params: P): void;
    onError(error: Error, params: P): void;
    onAfter(params: P, data: R, error: Error): void;
    onCancel(): void;
    onMutate(data: R): void;
};

declare const setGlobalOptions: (config: GlobalOptions) => void;

declare const definePlugin: (options: PluginImplementType<any, any>) => PluginImplementType<any, any>;

type DataType = {
    list: any[];
    [key: string]: any;
};
type LoadMoreService<R extends DataType> = (data?: R) => Promise<R>;
type LoadMoreBaseOptions<R> = Pick<Options<R, any>, 'ready' | 'manual' | 'refreshDeps' | 'refreshDepsAction' | 'debounceInterval' | 'debounceOptions' | 'throttleInterval' | 'throttleOptions' | 'errorRetryCount' | 'errorRetryInterval'> & {
    isNoMore?: (data?: R) => boolean;
    onBefore?: () => void;
    onAfter?: () => void;
    onSuccess?: (data: R) => void;
    onError?: (error: Error) => void;
};
type LoadMoreQueryResult<R extends DataType> = Pick<QueryResult<R, any>, 'data' | 'loading' | 'error' | 'refresh' | 'refreshAsync' | 'cancel' | 'mutate'> & {
    dataList: ComputedRef<R['list']>;
    noMore: ComputedRef<boolean>;
    loadingMore: Ref<boolean>;
    loadMore: () => void;
    loadMoreAsync: () => Promise<R>;
};
declare function useLoadMore<R extends DataType>(service: LoadMoreService<R>, options?: LoadMoreBaseOptions<R>): LoadMoreQueryResult<R>;

declare function useRequest<R, P extends unknown[] = any>(service: Service<R, P>, options?: Options<R, P>, plugins?: PluginImplementType<R, P>[]): QueryResult<R, P>;

declare const _default: (config: GlobalOptions) => void;

export { DataType, LoadMoreBaseOptions, LoadMoreQueryResult, LoadMoreService, Options, PaginationOptions, PaginationQueryResult, PluginImplementType, PluginType, QueryResult, Service, clearCache, definePlugin, setGlobalOptions, useLoadMore, usePagination, useRequest, _default as useRequestProvider };
